---
layout:     post
title:      堆栈总结
subtitle:   
date:       2018-06-07
author:     Alex Kinhoom
header-img: img/home-bg-art.jpg
catalog: true
tags:
    - 数据结构与算法
---
## 程序的内存分配
一个由`c/c++`编译的程序占用的内存分为以下几个部分<br>
1.栈区`stack`:由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。<br>
2.堆区`heap`:由程序员手动分配释放，若程序员不释放，程序结束时可能由os回收，注意它与数据结构中的堆是两回事，分配方式类似于链表。<br>
3.全局区(静态区)`static`:全局变量和静态变量的存储是放一块的。初始化全局变量和静态变量是在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后系统释放。<br>
4.文字常量区:常量字符串就是放在这里的。程序结束后由系统释放<br>
5.程序代码区:存放函数的二进制代码。
## 堆和栈的理论知识
### 申请方式
stack:由系统自动分配，例如，申明在函数中一个局部变量`int b`;系统自动在栈中为`b`分配空间。
heap:需要程序员自己申请，并指明大小。
### 申请后系统的相应
栈:只要栈的剩余空间大于所申请的空间。系统将为程序提供内存。否则将报异常提示栈溢出。<br>
堆:首先应该知道操作系统有一个记录空闲内存地址的链表。当系统收到程序的申请时。会遍历该链表。寻找第一个空间大于所申请空间的堆节点。然后将该节点从空闲节点链表中删除。并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小。这样。代码中的`delete`语句才能正确的释放本内存空间。另外，由于找到堆节点的大小不一定正好等于申请的大小。系统会将多余的那部分重新放入空闲链表中。
### 申请大小的限制
栈:在`windows`下，栈是向低地址拓展的数据结构。是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的。在`windows`下，栈的大小是`2M`(也可能是`1M`,总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示`overflow`。因此，能从栈获得的空间较小。<br>
堆:堆是向高地址拓展的数据结构。是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的。自然是不连续的。而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见。堆获得的空间比较灵活。也比较大。
## 申请效率的比较
栈由系统自动分配，速度较快。但程序员无法控制。<br>
堆是由`new`分配的内存，一般速度较慢。容易产生内存碎片。不过用起来最方便。
### 堆和栈中的存储内容
栈: 在函数调用时，第一个进栈的是主函数中的下一条指令<strong>函数调用语句的下一条可执行语句</strong>的地址。然后是函数的各个参数。在大多数的`c`编译器中，参数是由右向左入栈的。然后是函数中的局部变量。注意静态变量是不入栈的。<br>
当本次函数调用结束后，局部变量先出栈，然后是参数。最后栈顶指针指向最开始存的地址。也就是主函数的下一条指令。程序由该点继续运行。<br>
堆:一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。
### 例子
比如主函数里的语句 `int [] arr=new int [3];` 在内存中是怎么被定义的：<br>
主函数先进栈，在栈中定义一个变量`arr`,接下来为`arr`赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过`new`关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体。<br>
那么堆和栈是怎么联系起来的呢?<br>
我们刚刚说过给堆分配了一个地址，把堆的地址赋给`arr`，`arr`就通过地址指向了数组。所以`arr`想操纵数组时，就通过地址，而不是直接把实体都赋给它。这种我们不再叫他基本数据类型，而叫引用数据类型。称为`arr`引用了堆内存当中的实体。（可以理解为`c`或`c++`的指针，`Java`成长自`c++`和`c++`很像，优化了`c++`）。<br>
 如果当`int [] arr=null`;<br>
`arr`不做任何指向，`null`的作用就是取消引用数据类型的指向。
当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为`Java`有一个自动回收机制，（而`c++`没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以`Java`在内存管理上优于`c++`）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。<br>          
### 小结
堆和栈的区别可以用如下的比喻来看出：<br>
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。<br>
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。<br>
栈内存存储的是局部变量而堆内存存储的是实体。<br>
栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短。<br>
栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。<br>

